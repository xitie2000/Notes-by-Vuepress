#  Chapter 4 分布式系统体系结构

## 1 软件体系结构

### 1.1 某定义

软件体系结构（软件架构）是具有一定形式的结构化元素，即：组件的集合，包括：处理组件、数据组件和连接组件。处理组件负责对数据进行加工，数据组件是被加工的信息，连接组件把体系结构的不同部分组合连接起来

- 组件：是一个模块单元，它具有可以提供良好定义的接口，在其环境中是可替换的
- 连接组件（连接件）：描述为一种机制，在组件之间传递通信、使组件相互协调和协作

### 1.2 软件体系结构例：CORBA

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161655364.png" height=60% width=60%/>

## 2 体系结构样式

### 2.1 什么是软件体系结构样式

软件体系结构样式（Style，风格）是描述某一特定应用领域中系统组织方式的惯用模式。它反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统

- 批处理、管道过滤器、仓库、面向对象、分层…….

按这种方式理解，软件体系结构风格定义了用于描述系统的术语表和一组指导构建系统的规则

### 2.2 分布式系统中的重要样式

1. 分层体系结构
2. 基于对象的体系结构
3. 以资源为中心的体系结构
4. 基于事件的体系结构

#### 2.2.1 分层体系结构

分层系统组织成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的接口外，内部的层只对相邻的层可见

- 连接件通过决定层间如何交互的协议来定义
- 拓扑约束包括对相邻层间交互的约束

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161701072.png"/>

##### 分层体系结构例：三层B/S结构

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161703018.png" height=80% width=80% />

#### 2.2.2 基于对象的体系结构

- 对象将数据（对象状态）以及对数据的操作封装在了一起，通过接口，将其内部实现进行了隐藏

- 这里的对象可以是：对象、构件、服务

  - 分布式系统中，它们常常是远程的

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161705319.png)

##### 基于对象的软件体系结构例：CORBA

#### 2.2.3 以资源为中心的体系结构

- 这种风格的分布式系统可以看成是资源的集合，这些资源分别被相应的组件所管理，如
  - Web、Restful 架构
  - 数据库系统
- 资源能够被（远程）应用添加、删除、获取、修改
  - 资源的 CRUD
- Restful架构的四种操作

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161952889.png)

#### 2.2.4 基于事件的体系结构

- 组件间的通信，通过事件（可带有数据）的传播实现，如
  - 发布/订阅(publish/subscribe)系统:松耦合
  - 使用共享数据空间存储事件，可构成支持持久通信的发布订阅系统

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161953615.png)

#### 2.2.5 体系结构样式的混合

- 实际的分布式系统，常常混合了两种乃至多种样式

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161711163.png)

## 3 系统体系结构

### 3.1 简介

- 系统体系结构：软件体系结构的具体实例。确定了软件组件、这些组件的交互以及它们的位置（部署）就是软件体系结构的一个实例
- 也有观点把系统体系结构看作是一个软件系统的体系结构的一个视角
- 主要讨论
  - 集中式体系结构
  - 非集中式体系结构
  - 混合体系结构

### 3.2 集中式体系结构

- 顾名思义，服务功能集中在服务器侧
- 客户/服务器体系结构
  - 服务器：实现特定服务的进程
  - 客户：向服务器提出请求、等待应答的进程
  - 请求/应答模式

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161716512.png)

#### 3.2.1 集中式的层次例：搜索引擎

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161953260.png)

#### 3.2.2 各种各样的分层方式

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161718457.png)

### 3.3 非集中式体系结构

#### 3.3.1 从集中式到P2P

- 多层客户-服务器结构 --- 垂直分布性

  - 将不同功能组件放在不同的机器上
  - 有助于功能可以从逻辑、物理上分割在多台机器上，每台机器按特定功能进行定制

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161808448.png)

- 另一种体系结构 --- 水平分布性

  - 在物理上被分割成逻辑相等的几个部分
    - 每个部分都处理整个数据集中自己共享的部分
  - 进一步地：点对点（P2P）

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161953888.png)

- P2P 是一种分布式网络，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力等）和软件资源或者数据资源，这些共享资源能被其它对等节点（Peer）直接访问而无需经过中间实体。在此网络中的参与者既是资源提供者（Server），又是资源获取者（Client）

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161810706.png)

#### 3.3.2 P2P网络的拓扑结构示例

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161811943.png)

### 3.4 混合型体系结构

- 将客户/服务器结构与非集中式结构相结合

- 如：边缘服务器系统（edge server）

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161812567.png)

- 再如：协作式分布式系统

- 例：文件共享系统 BitTorrent

  - 强制每个参与者，即可下载文件，也负责上载文件
  - 全局目录：在Web站点中保存，基于它，可找到相应的 .torrent 文件，并进一步找到相应的tracker
  - 跟踪器（tracker）:记录活动节点的服务器

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161813333.png)

## 4 体系结构与中间件

### 4.1 简介

- 中间件是操作系统和应用软件之间的一个独立软件层，它在不改变现有操作系统的前提下，向分布式应用提供相应的执行环境和编程环境
- 中间件（分布式计算环境），能够屏蔽操作系统和网络协议的差异，能够为异构系统之间提供通讯服务以及各种通用服务的软件

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161816331.png)

### 4.2 Java EE中的中间件

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161816463.png)

java EE (Java Enterprise Edition)：一种平台规范，该平台提供了一套基于组件的方法来设计、开发、装配及部署N层结构的、面向Web的，以服务器为中心的企业级应用。2018年3月，开源组织Eclipse基金会宣布，Java EE（Enterprise Edition）被更名为Jakarta EE

### 4.3 中间件中的拦截器

- 拦截器（Interceptor） ：中间件中大多具有的一种组件，方便中间件的配置和定制
  - 可中断正常执行的控制流，插入执行其他代码
- 例：远程对象调用
  - 请求级拦截器
  - 消息级拦截器 

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161818338.png)

## 5 分布式系统服务架构演进

### 5.1 原始分布式时代

- 20世纪70、80年代
- 惠普公司提出了网络计算架构：RPC的雏形
- 卡耐基梅隆大学提出了AFS，Andrew File System：分布式文件系统的最早实现
- 麻省理工提出了Kerberos：服务认证和访问控制的基础性协议
- 开放软件基金会（国际开放标准组织）联合主流计算机厂商共同制定了DCE，分布式计算环境，包含一套相对完整的分布式组件规范与参考实现，如：
  - RPC、源自AFS的DFS
  - 源自Kerberos的服务认证规范
  - 时间服务、命名目录服务
  - UUID，Universally Unique Identifier

### 5.2 基于对象的体系结构

- 从原理上讲，所有的模块都可以被作为对象抽象出来，客户端通过调用对象的方式来获得服务和资源
- 分布式对象可以比较容易地把分布的特性隐藏在对象接口后面
  - 对象可以是任何东西

### 5.3 基于构件的体系结构

#### 5.3.1 基于构件的体系结构的引入

- 大量的应用程序，特别是同一领域中的应用程序，分享相似的结构。这些结构并没有经过通常的面向对象技术而得到重用。例如：
  - 各种面向对象的分布式应用系统，其远程通信、服务对象的创建激活去激活等生命周期管理、服务对象引用的发布和获取、安全事务控制等等功能的工作机制基本一致，可以共享

#### 5.3.2 基于构件的体系结构

- 基于构件的体系结构：框架 + 构件 + 对象总线
  - 框架：对问题的部分解决，是让用户集成构件的架构
    - 把握了某个领域内全部问题集解决方案的不变部分，开发者必须向框架添加变化部分代码以把握其动作，使该应用程序成为所在领域内特定的应用程序
  - 构件(组件)：构件是软件的基本单元， 既足够小，以便于维护，又应足够大，以使之具有功能，可以被打包和使用
    - 分布式对象就可以作为构件
  - 对象总线：使得构件和框架能够调用分布式环境中的另一构件或框架的服务
- 应用程序：20%（业务逻辑）+ 80%（框架+对象总线）

#### 5.3.3 构件模型

- 构件模型 = 构件 + 容器

  - 构件：具有可重用特性的基本软件部件
  - 容器：用于存放和安排构件，实现构件间的交互，并提供一系列可访问的管理服务，只要构件符合容器要求（规范），容器就可以让构件使用相应的管理服务
  - 容器提供的管理服务例
    - 生命周期管理、查询定位、安全服务、事务服务
    - 不同协议层的通信支持：远程通信、数据库访问

- 构件模型定义构件和容器的基本结构，制定构件和容器的基本接口，以及构件与构件之间、构件与容器之间交互的机制

- EJB构件与容器，Enterprise JavaBeans(EJB) ：Java服务器端服务框架的规范，软件厂商根据它来实现EJB服务器。应用程序开发者可以专注于支持应用所需的商业逻辑，而不用担心周围框架的实现问题

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161827853.png)

- 面向分布计算的构件模型中，不同容器间的构件可以交互，其交互的通信功能由容器提供，所以这种容器的功能可理解为：“基于构件的软件体系结构”上下文中的“框架+（对象）总线”

- 主流构件模型

  - CORBA的构件模型、EJB、COM（ DCOM / COM+ ）、Spring……

- 现在常用的框架一词，如Spring框架中的框架，可以理解为是一种构件模型

#### 5.3.4 ORM

- Object/Relation Mapping

- ORM是一种为了解决面向对象技术与关系数据库间存在的互不匹配问题的技术

  - 把对数据库的操作也封装为构件，解决了面向对象和数据库之间的矛盾，完成对象和数据库表之间的数据转换，让开发人员可以用面向对象的思想来操作数据库

- 实现ORM技术例

  - Hibernate、 MyBatis

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161831624.png)

#### 5.3.5 重量级框架

- 典型代表EJB 1/2
- 开发的系统需要放置在一个容器系统中进行运行，并 **需要实现容器要求的接口**
- 容器在实例化业务对象后，传给业务对象上下文，而业务对象本身 **要通过JNDI手段来定位或者pull出其他资源或者业务对象**
- 这些容器因为基本针对大型企业应用，所以体积庞大，占用资源，内在服务多，启动比较慢
- 开发需要遵从的规则比较多，开发效率也比较低，很大一部分时间都用在了Deploy、Run这样的过程上，调试和测试比较困难

##### HelloWorldBean 类

```java
package testejb;
import javax.ejb.*;
// 根据EJB的种类决定要实现什么接口
public class HelloWorldBean implements SessionBean, HelloWorld {
    // EJB开发人员访问容器上下文的入口
    SessionContext sessionContext;
    public void ejbCreate() throws CreateException {}
    public void ejbRemove() {}
    public void ejbActivate() {}
    public void ejbPassivate() {}
    // 用来初始化sessionContext变量；每次创建一个session bean时，容器会调用
    public void setSessionContext(SessionContext sessionContext) {
    	this.sessionContext = sessionContext;
    }
    // 本例EJB的远程方法
    public String sayHello() {
    	return "Hello World";
    }
}
```

##### 用于生命周期管理

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161838270.png)

#### 5.3.6 轻量级框架

- 典型代表：Spring
  - EJB 3也努力轻量化
- 以依赖注入（Dependency Injection）为代表的解耦合模式，可以让构件不去依赖容器（运行环境）的API
- 轻量级容器通过反向控制（Inversion of Control）让容器具有主动权，去管理插进来的组件，只要组件是符合标准的，就可以被轻量级容器管理
- 构件以POJO（Plain Old Java Object）的形式存在，只要你有 Java.exe 就可以运行它，不需要容器就可以实现测试行为

##### 依賴性(Dependency)

- 当某个类继承另一个类、实现另一个接口或者调用其他类，我们就说该类依赖（depends-on）另一个类

- 依賴性(Dependency)会对源代码的可重用性造成负面影响

  - 依赖性越低，程序的可重用性越高

- Liskov替换原则也可以看成是降低依赖性的方法

  - 将Client与实现类之间用接口分离，就可以解除Client与实现类之间的依赖关系

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161842888.png)

##### 控制反转与依赖注入

- 传统的程序开发，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类耦合起来

- 在轻量级容器里，创建被调用者实例的工作不再由调用者来完成，而通常由容器来完成，因此称为控制反转（Inversion of Control，IoC） ，容器将所创建的实例注入调用者，因此称为依赖注入(Dependency Injection，DI)

- Martin Fowler建议使用依赖注入来描述 “对象生成控制权” 的倒置

- 颠覆了“使用对象之前必须创建” 的基本Java语言定律 ，降低了模块之间的耦合度，提高了应用的灵活性和代码重用度

- 对象生成控制权的倒置

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161844229.png)

- 依赖注入（DI）

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161845087.png)

##### Spring Bean容器执行方式

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161846242.png)

##### DI例：通过setter

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161847460.png)

##### EJB3.0有状态会话Bean举例

```java
@Stateful public class AccountManagementBean implements AccountManagement { 
    Socket cs; 
    @PostConstruct 
    @PostActivate 
    public void initRemoteConnectionToAccountSystem { ... } 
    
    @PreDestroy 
    @PrePassivate 
    public void closeRemoteConnectionToAccountSystem { ... } 
    ... 
}
```

##### 事务举例

```java
@Stateless public PayrollBean implements Payroll { 
    public double getSalary(int empid) {...} 
    
    @TransactionAttribute(MANDATORY) 
    public void setSalary(int empId, double salary) {...} 
}
```

##### 安全举例

```java
// EJB 3.0: Security View
@RolesAllowed(HR_Manager)
@Stateless public class PayrollBean implements Payroll {
    public void setSalary(int empId, double salary) {
    	...
    }
    @RolesAllowed({HR_Manager, HR_Admin})
    public int getSalary(int empId){
    	...
    }
}
```

#### 5.3.7 面向构件相关技术

- 技术的重点不在于如何进行远程调用
  - RPC或者RMI技术足以支持，目前也有很多支持远程调用的框架
- 技术重点：如何简化应用的开发、维护
  - 由容器提供相应的各种服务：事务、安全、持久化等
- 进一步地：轻量级框架技术把框架服务传递给松散耦合的简单旧式Java对象（POJO）。这些框架服务组件通过在运行时截取执行内容或向POJO注入服务对象，把服务与POJO捆绑在一起。POJO本身不关心捆绑的过程，并且对框架、组件几乎没有依赖
  - 松耦合基于构件的应用与容器的关系，只整合需要的服务
  - 松耦合构件之间的关系

#### 5.3.8 关于框架

- 框架：功能越强越好？NO！
- 现在的一个趋势是框架只做最关键的东西，不需要封装太多功能
  - 很多互联网公司的产品小而精，要求开发效率高、性能好，而对事务等功能的要求不高
  - 而且大多程序员更愿意把学习的精力放在底层如servlet、sql上，而不是struts2、 Hibernate等框架上
- 因此，与SSH相比，SSM、SpringBoot更受欢迎
  - SSH：Struts2、Spring、Hibernate
  - SSM：springMVC、Spring、 MyBatis
  - SpringBoot：可看作Spring框架的扩展，是一个轻量级、简化配置和开发流程的web整合框架

### 5.4 面向服务的体系结构

SOA（Service Oriented Architecture）是一种 C/S 架构的软件设计方法，应用由服务和服务使用者组成，它着重强调构件的 **松散耦合**，并使用独立的 **标准接口**

- 将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来
- 接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言，使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互
  - 方便异构系统互联、应用集成、遗留系统集成

#### 5.4.1 SOA

- SOA的概念最早由Gartner公司在1994年提出，当时还不具备发展的条件
  - 早期的分布式技术无法实现普遍的互联
    -  DCOM需要每个连接点都使用Windows
    - OCRBA需要每个连接点都有ORB
    - RMI需要每个连接点都使用Java
- 随着上世纪末XML、基于XML的SOAP协议等技术的提出和广泛应用，Web Service技术在本世纪最初的十年风头一时无两，其对SOA思想的天然契合性，使得SOA在当时非常盛行
  - 简单的XML格式
  - 可以在任意平台使用任意技术
  - 可以使用开放源代码资源

#### 5.4.2 Web Service

- 对象接口描述: WSDL
- 对象访问: SOAP
- 对象接口发现: UDDI
- 对象实现: 任何可用于对象实现的技术

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161859964.png)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161900816.png)

- 要构造一个新的业务流程，可以从Service Broker中发现现有的服务，最大限度地重用现有的服务，通过服务流程的编排来构建新的服务

#### 5.4.3 SOA与ESB

- ESB：企业服务总线，可以松散耦合地集成不同系统、不同协议的服务
- 所有服务都可以在ESB上插拔，通过总线的流程编排、协议转换、路由等功能来组合服务实现业务逻辑功能

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161922294.png)

#### 5.4.4 SOA的问题

- Web Service中，基于XML的SOAP、WSDL等过于严格的数据和接口定义带来了复杂性和性能问题
  - XML本身信息密度相对低下
  - 要跨语言，使得一个简单的字段，为了在多种语言中不产生歧义，需要多出十几倍、几十倍甚至上百倍的空间
- 构建在SOAP之上的ESB等进一步加重了这种复杂性和性能问题
- 希望在一套协议上一揽子解决分布式计算中可能遇到的所有问题：事务、一致性、事件、安全……：复杂
- 虽然SOA可以实现多个异构大型系统之间的复杂交互集成，却很难作为一种具有普适性的软件架构风格来推广
  - 与CORBA、EJB类似

### 5.5 REST风格的体系结构

详见第三章 4.2 REST

### 5.6 微服务体系结构

#### 5.6.1 强行追求简单透明分布的问题

- DCE、CORBA等的基本思想：构建符合UNIX设计哲学的，如同本地调用一般简单透明的分布式系统
  - UNIX分布式设计哲学：保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都更加重要，Richard P. Gabriel，1991
- DCE、CORBA尽力做到了相对透明
  - 但远程与本地的性能差距巨大
  - 将一个系统拆分到不同的机器中运行，为解决服务发现、跟踪、通信、容错、隔离、配置、数据一致性和编码复杂度等方面的问题所付出的代价已远远超过了分布式所取得的收益
- IBM院士Kyle Brown事后曾评价（2016）：
  - 这次尝试最大的收获就是对RPC、DFS等概念的开创，以及得到了一个价值千金的教训：某个功能能够进行分布，并不意味着它就应该进行分布，强行追求透明的分布式操作，只会自寻苦果

#### 5.6.2 单体架构

单体架构是在整个软件架构演进史出现时间最早、应用范围最广，使用人数最多的、统治历史最长的一种架构风格，但 “单体” 这个词是微服务开始流行之后才“事后追认”所形成的概念

- 将系统某个层次所有模块化组件混合后运行在同一个进程中
- 可对包含多个组件的整个进程进行水平扩展，无法对某个组件进行水平扩展
- 某个模块化组件发生变化时，需要所有的组件进行编译、打包和上线
- 随着时间推移，模块间依赖越来越不清晰，相互耦合、相互依赖的问题越来越严重

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161929258.png)

#### 5.6.3 微服务体系结构

- 微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元
- MSA（Microservices Architecture）：
  - 微服务架构风格就是把小的服务开发成单一应用的形式，运行在其自己的进程（或容器）之中，并采用轻量级的机制进行通信（一般是HTTP资源API）
  - 服务都是围绕业务能力来构建的，通过全自动部署工具来实现独立部署
  - 服务可以使用不同的编程语言和不同的数据存储技术，并保持最小化集中管理
- MSA的出现绝非偶然
  - 将业务功能服务化，SOA思想的延续
  - Restful的兴起，支持轻量级通信
  - 虚拟化、容器技术的发展，简化了服务的自动部署、安装和管理
  - DDD（领域驱动设计）分析并模型化复杂的业务
  - ....

#### 5.6.4 微服务架构 vs 单体架构

- 把每一个职责单一的功能放在一个独立的服务中
- 每个服务可以有多个实例在运行，每个实例运行在一个单独的进程或容器中，故障隔离
- 每个服务有自己的数据存储、缓存、队列等资源
- 每个服务应该有自己独立的运营平台，以及独享的运营人员，包括技术运维和业务运营
- 每个服务都高度自治，内部的变化对外透明
- 每个服务都可根据需求独立地进行水平扩展

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161934462.png)

#### 5.6.5 分布式服务框架

- 为什么微服务架构需要分布式服务框架？
  - 当服务越来越多时，服务 URL 配置管理变得非常困难，负载均衡器的单点压力也越来越大
  - 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动
  - 服务的调用量越来越大，服务的容量问题就暴露出来，某个服务需要多少机器支撑？什么时候该加机器？
- 分布式服务框架例
  - Dubbo
  - Spring Cloud
  - Service Mesh

#### 5.6.6 分布式服务框架例：Dubbo

- Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，不仅支持高性能的RPC远程服务调用支持，还对服务治理提供了支撑。可以和 Spring 框架无缝集成，现已发展成为Apache的顶级孵化开源项目
  -  提供RPC支持，只需简单配置，没有API侵入
  - 服务自动注册和发现，注册中心基于接口名查询服务提供者IP地址，并能够在线添加或删除服务提供者
  - 软负载均衡及容错支持

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161936074.png)

1. 服务容器负责启动，加载，运行服务提供者
2. 服务提供者在启动时，向注册中心注册自己提供的服务
3. 服务消费者在启动时，向注册中心订阅自己所需的服务
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

#### 5.6.7 分布式服务框架例：Spring Cloud

Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由等，满足了构建微服务所需的所有解决方案

- Eureka：服务治理组件，包含服务注册、发现
- Hystrix：容错管理组件，实现了断路器
- Zuul：API网关组件，提供智能路由、访问过滤等功能
- Ribbon：客户端负载均衡的服务调用组件
- RestTemplate/FeignClient 服务调用组件

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161940601.png)

#### 5.6.8 MSA不是放之四海而皆准

- 使用微服务架构构建应用也有相应的一些困难，如
  - 不使用事务实现跨服务的业务逻辑更加困难
  - 测试更加困难
  - 跨服务的业务需要团队间的细致合作
  - 生产环境部署复杂度高
- 微服务架构需要依赖于“基础设施自动化”来实现相应的非功能性需求，如
  - 事务
  - 服务治理：注册、发现、负载、路由、认证授权、隔离
  - 监控：日志、告警、性能监控、链路监控
  - 部署、测试
- 是否采用、何时采用微服务需考虑企业自身的需求

### 5.7 Serverless 体系结构

#### 5.7.1 从物理机到Serverless

<a href="https://baijiahao.baidu.com/s?id=1722335096951078263&wfr=spider&for=pc" target="_blank">一文读懂 Serverless 的起源、发展和落地实践</a>

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161943291.png)

#### 5.7.2 Serverless

- 无服务器：用于构建和运行不需要进行服务器管理的应用系统的概念
- Serverless computing：是一种按需提供后端服务的方法。无服务器提供者允许用户编写和部署代码，而不必关心底层基础结构。从无服务器供应商处获得后端服务的公司将根据其计算费用，而不必保留和支付固定数量的带宽或服务器数量，因为该服务是自动伸缩的
  - 尽管称为无服务器，但仍使用物理服务器，但开发人员无需了解它们

<a href="https://www.jianshu.com/p/92632d6c2269" target="_blank">Serverless</a>

- 一般认为，Serverless = FaaS + BaaS
  -  FaaS：函数即服务，函数运行在无状态的容器中，可以由事件触发
    - 如：阿里云的函数计算、AWS 的 Lambda
  - BaaS：后端即服务，如云数据库、对象存储、消息队列等，利用 BaaS，可以极大简化应用开发难度

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202211161946943.png)

## 6 本章总结

- 分层、基于对象、基于事件、以资源为中心等体系结构风格，是分布式系统的基本风格/样式
- 分布式系统可以是集中的、也可以是P2P的，也可以是混合的
- 分布式应用系统的构建、运营，需要基于分布式计算环境（中间件）。中间件可以拦截分布式系统中组件之间的交互，从而可以方便地进行配置、定制，插入需要的功能
- 分布式系统的服务架构经历了从基于过程、基于对象、基于构件、面向服务，到Restful、微服务、Serverless的演进
- 软件开发的未来不会只存在某一种最先进的架构风格/样式，多种具有针对性的架构风格将并存

