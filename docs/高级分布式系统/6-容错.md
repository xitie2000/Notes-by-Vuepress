# Chapter 6 容错

## 1 分布式容错模型

### 1.1 基本概念

- 可靠/可信系统（Dependable, Trustworthy）
  - 可用性（availability）
    - 在任何给定时刻能正确操作的概率
    - 可用性= (平均正常工作时间/ (平均正常工作时间+ 平均修复时间))
  - 可靠性（Reliablity）
    - 在给定时间间隔内能正确操作的概率
  - 安全性（Safty）
    - 含义1：临时失效不会造成灾难
    - 含义2：系统或数据不会被破坏、更改、泄
  - 可维护性（Maintainability）
    - 系统发生故障后进行修复的难易程度
- 失效（fail, failure）、失败
  - 一个系统不能兑现它的承诺（提供服务）
- 差错（error）
  - 导致系统失效的系统状态
    - 如一些数据包在到达接收方时与原来的不一致了
- 故障（fault）
  - 导致差错发生的原因
    - 如传输介质坏了
    - 如无线传输时的恶劣天气
- 故障类型
  - 短暂型(transient):出现一次，再也不出现
    - 例：一只鸟从微波电波中飞过
  - 间歇型(intermittent)：消失后，再重复出现
    - 例：接触不良
  - 永久型(permanent)：一直存在
    - 例：文件损坏
- **容错（fault tolerance）**
  - 即使发生故障，系统仍能提供服务

### 1.2 一种进程失效分类方式

| 失效类型                                           | 服务器行为描述                                               |
| -------------------------------------------------- | ------------------------------------------------------------ |
| 崩溃性失效                                         | 服务器停止。但在停止前一直正确工作                           |
| 遗漏性失效<br>      接收遗漏<br>      发送遗漏     | 服务器不能响应到来的请求<br>服务器不能接收到来的消息<br>服务器不能发送消息 |
| 定时性失效                                         | 服务器的响应超出规定的时间间隔                               |
| 响应性失效<br/>      值失效<br/>      状态变迁失效 | 服务器的响应不正确<br/>响应的值是错误的<br/>服务器偏离正确的控制流 |
| 任意性失效                                         | 服务器可能在任意的时刻产生任意的响应                         |

### 1.3 进程崩溃的发现

- 当进程P在一定时间段内感知不到进程Q的任何动作，P能得出Q崩溃的结论吗？
  - 同步系统：进程的执行速度和消息传递时间是有限制的
    - 能
  - 异步系统：没有进程执行速度和消息传递时间的假设(限制)
    - 不能
- 纯同步系统只存在于理论中，实际的分布式系统通常是异步的
  - 无法判断进程是否crash？
- 现实的做法是，假设分布式系统是部分同步的（partially synchronous）
  - 在大多数时间里，都按同步系统那样工作，异步行为只是一种异常
  - 在大多数时间里，基于超时得出的进程崩溃结论是正确的，只是偶尔的情况下是错误的

### 1.4 另一种进程失效分类方式

- 失效即停 (fail-stop)：一般指崩溃性失效
- 失效嘈杂(fail-noisy)：类似崩溃性失效，但是需要一个先验未知的时间来最终判断出进程不可靠了
- 失效沉默(fail-silent)：可能是崩溃性失效，也可能是遗漏性失效
- 失效安全(fail-safe)：产生不确定响应，但响应易被识别，不产生恶果
- 随意性（arbitrary)失效：比如不响应、发送错误信息、对不同节点发送不同决定、不同错误节点联合起来干坏事等等
  - 也叫拜占庭(Byzantine) 失效，恶意的、难检测
    - 拜占庭帝国（330-1453）

### 1.5 基于冗余的失效屏蔽技术

- 冗余类型
  - 信息冗余：如，海明码
  - 时间冗余：如，重发，重做
  - 物理冗余：
    - 软件:如复制进程
    - 硬件：如复制电路、网卡
  - 信息冗余和物理冗余都属于空间冗余
- 三模冗余方法(TMR,Triple Modular Redundancy)
  - 三路表决器(voter)：三路输入，一路输出
  - 可屏蔽一路错误（任意性失效）

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221121171510.png)

## 2 RPC的失效问题

### 2.1 RPC失效

RPC有5种失效情况

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221121171600.png)

#### 2.1.1 客户不能定位服务器

- 可能服务器发生故障
- 可能服务器被修改，客户存根（stub）与新的服务器存根不匹配
- 解决策略：
  - 抛出异常信号SIG-NOSERVER，然后由编写的信号处理程序做相应处理。
  - 没有透明性：需要编写异常处理程序

#### 2.1.2 丢失请求消息

- 解决策略：
  - 客户发现超时，重发请求
  - 频繁丢失，一般认为“不能定位服务器”

#### 2.1.3 服务器崩溃

- 崩溃情况

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221121171857341.png)

- 解决策略：

  - 至少一次语义：重发
  - 最多一次语义：丢弃
  - 听之任之，什么都不保证
  - 恰好一次语义：很难：客户端无法知道什么情况下崩溃的

#### 2.1.4 丢失应答消息

- 解决策略
  - 定时器，超时检测，重发请求
- 问题：重复操作
  - 解决策略
    - 构造幂等性操作（idempotent）：可以安全地重复多次而不会造成任何损害的操作
    - 非幂等操作
      - 序号
      - 标志：区分原始消息和重发消息

#### 2.1.5 客户崩溃

- 孤儿进程问题：没有关注该进程计算结果的进程存在。
  - 造成资源浪费；造成结果混淆
- 解决策略：
  - 过期法：设置时间量T。如果超过T，则撤销客户的请求（不一定是孤儿）
  - ......

## 3 进程的恢复力（Resilience）

### 3.1 强的恢复力：复制到组

- 为防止进程失败，把进程复制到组
  - 当消息发送到组时，组中所有成员都接收它，一个进程失败，其他进程可以接管它
- 进程组是动态的
- 进程组可以是
  - 平等组：无单点失效；达成共识增加延迟和开销
  - 简单等级组：单点失效

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221121173348.png)

### 3.2 故障掩盖和复制

- 复制进程，用一个容错的进程组来代替一个脆弱的进程
- 需要多少复制?
  - 如果系统能经受K个组件的故障而且能满足规范的要求,被称为K容错的
  - 如果组件是失效沉默的，具有K+1个组件即可
  - 如果组件发生拜占庭失效（ Byzantine failure ），继续错误运行，则至少需要2K+1个组件才能获得K容错
    - 拜占庭失效：一个有故障的进程可能会对其它进程发出干扰消息，从而影响这些进程的正常工作
    - 拜占庭失效是所有失效类型中最严重的

### 3.3 故障系统的协定问题

- 协定(agreement，consensus)
  - 对某些问题的一致意见。如：选择一个协调者，是否提交事务，在工作者之间划分任务
- 分布式共识算法
  - 在有限的步骤内，所有非故障进程达成协定

### 3.4 共识算法的分类

- 非拜占庭容错类算法（Crash Fault Tolerance，CFT）：针对常见的非拜占庭错误情况。特点是性能好，容忍不超过一半的故障节点，代表算法
  - Paxos、Raft、Zab等
- 拜占庭容错类算法（Byzantine Fault Tolerance， BFT ）：针对能容忍拜占庭错误的情况，特点是性能差，容忍不超过1/3的故障节点。两类代表：
  - PBFT（Practical Byzantine Fault Tolerance）确定性系列算法：一旦达成共识不可逆转，就是最终结果
  - PoW概率算法：共识是临时的，随着时间推移或变化，共识结果被推翻的概率越来越小，成为最终结果
- 特殊的XFT（Cross Fault Torelrance）等算法可以提供类似CFT的处理性能，并能在大多数节点正常工作时提供BFT保障

### 3.5 失效检测

- 失效检测是分布式系统容错的基石
- 进程失效检测
  - 主动式方法，发送 “Are you alive?”消息
    - 常用方法， ping操作
  - 被动式方法，等待发来的故障消息
  - 超时机制，在规定时间内作出响应，否则，为故障
- 失效检测子系统应该能够区分是网络失效还是节点失效
  - 不要只用一个节点去判断另一个节点是否失效

## 4 可靠的分组通信

### 4.1 概念

- 可靠多播:发送到一个进程组的消息被传递到该组的每个成员
- 基本的可靠多播方法：假定所有的接收者已知而且假定不会失败的简单可靠多播方法
  - 接收方数量不多
- 可靠多播的可扩展性：接收方数量比较多
- 原子多播：实现存在进程失败的情况下的可靠多播：保证所有正常组员都按照相同的顺序接收到消息
  - 如果通信期间有进程加入
  - 如果通信期间一个（发送）进程崩溃

### 4.2 例：基本的可靠多播模式

假定所有的接收者已知而且假定不会失败的简单可靠多播方法

a) 消息传播：记录顺序号

b) 报告反馈：如果丢失，返回NACK，重新发送

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221121174207.png)

## 5 恢复处理（Recovery）

### 5.1 恢复处理

- 目的: 使系统从错误状态到正确状态
- 类型：
  - 向后恢复(backward recovery)：使系统返回到上一个正确状态：需要在必要时记录系统状态
    - 恢复状态一般开销较大
    - 恢复后不能保证不发生类似错误
  - 向前恢复(forward recovery)：使系统前进到一个正确的新状态：需要预知会发生什么错误
- 检查点技术(checkpoint)
- 消息日志技术（logging）
  - 基于发送者也可基于接收者写日志

### 5.2 检查点

- 每次记录系统的当前状态时，称为设置一个检查点
- 分布式快照（snapshot）
  - 一致的全局状态：若P收Q发，如果进程P记录了一条消息的接收，那么Q就要记录该条消息的发送
- 恢复线路
  - 最近的分布式快照，最近的一致性割集（cut）

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221121174633506.png)

#### 5.2.1 独立检查点

- 独立检查点
  - 每个进程的检查点是相互独立的
- 问题：多米诺效应
  - 局部状态没有形成分布式快照，导致级联回滚（cascaded rollback）过程
  - 举例：只有m,m'的接受记录，没有发送记录
- 有相应解决算法

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221121174755076.png)

#### 5.2.2 协作式检查点

- 非阻塞式算法
  - 有相应的分布式快照算法
- 两阶段阻塞式算法
  - CHECKPOINT_REQUEST：
    - 协调者发送命令，所有进程写局部检查点，向协调者返回ACK消息
  - CHECKPOINT_DONE：
    - 当协调者收到所有的ACK后，发送命令，所有进程继续

### 5.3 消息日志

- 基本思想
  - 减少检查点的个数
  - 如果消息的传送可以重放(replay)，则可取得全局一致性状态，而不必从稳存恢复
- 分段确定性模型(piecewise deterministic model)，假定：
  - 每个进程在一连串的间隔中执行，有先后次序，是确定性的。每个间隔是可重放的
  - 每个间隔以一个非确定性事件开始（如一个消息的接收），以下一个非确定形事件发生而结束
  - 如果以相同的非确定性事件作为开始进行重放，那么一个间隔的重放可以具有确定的结果
  - 如果记录所有非确定性事件，则全部执行可重放

