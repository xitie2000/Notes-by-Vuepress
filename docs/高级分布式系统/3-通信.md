# Chapter 3 通信

## 1 分层通信协议

### 1.1 OSI 模型

#### 1.1.1 简介

- 由于没有共享存储器，分布式系统中的所有通信是基于（低层）消息交换的
- OSI模型（开放式系统互联参考模型）用来支持开放式系统间的通信
- 开放式系统是可以通过标准规则与其他开放式系统通信的系统，这些规则规定了发送和接收消息的格式、内容以及相应的含义

#### 1.1.2 OSI模型中的层、结构和协议

- 分层：功能分解。独立性
- 接口（提供功能的操作集）：标准化
- 协议栈：有序性

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030171307.png" style="zoom:80%;" />

#### 1.1.3 典型消息格式

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030171449.png" style="zoom:80%;" />

### 1.2 应用层协议

- 在OSI七层模型的传输层之上划分了三个层，在实践中，只用到了其中的应用层
- 在Internet协议簇中，传输层之上的所有内容都合并到了一起，称为应用层
  - 应用层成为所有由于各种原因不能归纳到某个较低层中去的应用程序和协议的容器
- 缺乏对应用程序、针对特定应用程序的协议以及通用协议的明确区分
  - ftp协议和ftp程序
  - HTTP协议

### 1.3 中间件

#### 1.3.1 中间件协议

- 有的应用层协议，可用于支持多种应用程序的通信，因此可看做是对多种应用程序有用的通用协议
  - 但不能算作传输层协议，很多情况下归入 **中间件协议**
- 中间件协议：中间件使用的，用于建立各种中间件服务的协议，如支持通信、认证、事务、容错……
- 不同的中间件系统有不同的中间件协议，如
  - 支持远程过程调用的协议，如
    - CORBA的IIOP
    - Java RMI的JRMP
    - Web Service的SOAP和HTTP
    -  gRPC的HTTP/2
  - 支持实时流数据传输并保持同步的协议
  - 可靠多播协议，用于支持可靠多播服务的中间件系统

#### 1.3.2 中间件层

中间件层在通信中所处的位置：

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030172025.png" style="zoom:80%;" />

#### 1.3.3 中间件支持的通信类型

- 从通信持久性方面
  - 持久通信：传输的消息一直由通信中间件存储，直到该消息被传送给接收方，如电子邮件系统
  - 瞬时通信：通信中间件只在发送和接收应用程序正在运行的时候才存储消息，即由于传输中断或者接收方当前不在活动状态，中间件就不传输消息，而是丢弃消息
- 从通信同步性方面
  - 同步通信：发送方提交消息后将被阻塞，直到某个事件发生：发送方可有三类同步点
    - 基于发送：中间件确认接管消息传送
    - 基于接收：请求被传送到目标接收方
    - 基于响应：接收方返回响应
  - 异步通信：发送方在提交要传输的消息后立刻接着后续的执行，不会阻塞
    - 发送方提交的消息立刻被中间件存储
- 从通信连续性方面分：不连续通信和流通信
- 这些通信方式可以进行各种组合

#### 1.3.4 通信持久性和同步性的组合例

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030172453.png" style="zoom:80%;" />

## 2 套接字

### 2.1 面向消息的瞬时通信：套接字

- 很多分布式系统和应用程序直接构建在传输层提供的简单的面向消息的模型之上
- 程序员通过一个简单的原语集就可以使用传输层提供的全部（消息传递）协议
  - 标准化的原语集接口使得应用程序在不同机器之间的移植变得容易
- 如支持TCP/IP的Berkeley套接字socket

### 2.2 TCP/IP套接字原语

| 原语    | 意义                             |
| ------- | -------------------------------- |
| Socket  | 创建新的通信端点                 |
| Bind    | 将本地地址附加(attach)到套接字上 |
| Listen  | 宣布已准备好接受连接             |
| Accept  | 在准备好连接请求之前阻塞调用方   |
| Connect | 主动尝试确立连接                 |
| Send    | 通过连接发送数据                 |
| Receive | 通过连接接受数据                 |
| Close   | 释放连接                         |

### 2.3 使用套接字的面向连接通信模式

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030173035.png)

### 2.4 套接字编程

```java
// Server:
ServerSocket server = new ServerSocket(10000);
while (true) {
	Socket s= server.accept();
	new ServerThread(s).start();
}

// Client
Socket s = new Socket(“192.168.2.1”,10000);
InputStream is = s.getInputStream();
is.close();
s.close();
```

## 3 应用层协议和中间件协议例：HTTP

### 3.1 HTTP 简介

- HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从Web服务器传输超文本到本地浏览器的传输协议
- 工作于客户端-服务端架构上。浏览器作为HTTP客户端，通过URL向HTTP服务端即WEB服务器发送所有请求
- 基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）
  - 默认端口号为80，但是也可以改为8080或者其他端口

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030173500.png)

### 3.2 HTTP 请求

#### 3.2.1 HTTP 请求响应交互

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221030173717217.png" style="zoom:80%;" />

1. 在用户点击URL为http://www.bupt.edu.cn/index.html的链接后，浏览器执行以下动作：
   1. 浏览器分析超链接中的URL
   2. 浏览器向DNS请求解析www.bupt.edu.cn的IP地址
   3. DNS将解析出的IP地址124.127.207.15返回浏览器
2. 浏览器与服务器建立TCP连接（80端口）
3. 浏览器请求文档：GET /index.html
4. 服务器给出响应，将文档 index.html 发送给浏览器
5. 释放TCP连接
6. 浏览器显示index.html中的内容

#### 3.2.2 HTTP的消息格式

- HTTP消息分为请求消息和响应消息两类

- 请求消息：从客户端(浏览器)向Web服务器发送的请求报文

- 请求消息例：

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174300.png" style="zoom: 67%;" />

#### 3.2.3 请求消息中的方法

方法(Method)是对所请求对象所进行的操作，也就是一些命令。请求报文中的操作有

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174506.png" style="zoom:80%;" />

#### 3.2.4 响应消息

- 从Web服务器到客户机(浏览器)的应答

- 响应消息例：

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174739.png" style="zoom:67%;" />

#### 3.2.5 响应消息中的状态码

状态码(Status-Code)是响应报文状态行中包含的一个3位数字，指明特定的请求是否被满足，如果没有满足，原因是什么。状态码分为以下五类

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221030174848782.png)

#### 3.2.6 HTTP消息结构:首部字段或消息头

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174930.png)

### 3.3 HTTP的连接方式

- 非持久性连接
  - 即浏览器每请求一个Web文档，就创建一个新的连接，当文档传输完毕后，连接就立刻被释放
  - HTTP/1.0、HTTP/0.9采用此连接方式
- 持久性连接
  - 即在一个连接中，可以进行多次文档的请求和响应。服务器在发送完响应后，并不立即释放连接，浏览器可以使用该连接继续请求其他文档
  - HTTP/1.1默认使用持久连接

### 3.4 HTTP/1.x的主要问题

- HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟
- 单向请求，只能由客户端发起
- 请求报文与响应报文首部信息冗余量大
- 数据未压缩，导致数据的传输量大

### 3.5 HTTP/2主要的新特性

- **二进制分帧**：HTTP/1.x通过文本的方式传输数据，HTTP/2中引入了新的编码机制，所有传输的数据都会被分割为帧，并采用二进制格式编码
- **多路复用**：HTTP/2中,基于二进制分帧层，可以在共享TCP连接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。 通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能
- **首部压缩**：HTTP/1.x的header带有大量信息，而且每次都要重复发送，HTTP/2使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
- **服务器推送**：服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221030175508853.png" style="zoom:80%;" />

参考：<a href="https://blog.csdn.net/weixin_41605937/article/details/108306408" target = "_blank">计算机网络——HTTP协议原理</a>

### 3.6 HTTP的无状态性

- 无状态协议，是指协议对于交互性场景没有记忆能力，协议本身并不保留之前一切的请求或响应报文的信息
- 对于一般的Web资源而言，一个URL对应着唯一的超文本，而HTTP服务器也绝对公平公正，不管请求者是谁，之前还请求过什么，它都会根据接收到的URL请求返回相同的超文本。**每次请求都是独立的**
  - 这样，记录用户的行为状态变得毫无意义，所以，HTTP协议被设计为无状态协议符合它本身的需求
- HTTP的无状态性简化了服务器的设计，使其更容易支持大量并发的HTTP请求
  - 集群、cache都方便
- 为支持有状态的服务，HTTP引入了Cookie技术，例如
  - 当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标识Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 进行保存
  - 在这个会话期间，浏览器每次请求都会额外加上这个参数值，服务器根据这个 SessionId，就能取得该客户的会话信息进行有针对性的响应
- Cookie技术为传递用于标识客户身份或者会话ID的信息提供了支持，**但这些信息并不是协议自身保存的**
  - HTTP仍然是一个无状态协议

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030135416.png" style="zoom:80%;" />

### 3.7 HTTP做中间件协议：传输SOAP

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180031.png" style="zoom:80%;" />

## 4 访问远程服务

### 4.1 远程过程调用RPC

#### 4.1.1 RPC概述

- **R**emote **P**rocedure **C**all：像调用本地过程一样，调用远程过程

  - 调用者和被调者都不用考虑通信问题

  - 沿用用户熟悉的编程模式，调用远端过程并将结果返回

- 通信一般采用同步方式（Request-Wait-Reply）

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180323.png" style="zoom:80%;" />

#### 4.1.2 远程过程调用机制

- 在发送方（调用方）的地址空间里创建一个远程组件（如过程）的代理（客户侧Stub）；在接收方（被调用方）的地址空间里创建一个发送方代理（服务器侧Stub）

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180435.png" style="zoom:80%;" />

- 发送方只和本地客户侧Stub通信；接收方从本地服务器侧Stub得到所有的请求

- 组件间的远程通信封装在代理／Stub通信中，它是由建立在中间件API基础上的IDL编译器生成的

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180625.png" style="zoom:80%;" />

#### 4.1.3 远程方法调用RMI

像调用本地对象的方法一样，调用远程对象的方法，调用者和被调者都不用考虑通信问题。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180743.png)

#### 4.1.4 RPC的执行语义

- RPC百分百一次性调用成功是非常难以实现的，例如：
  - 如果服务器在执行过程调用之前崩溃或请求消息丢失
    - 客户端不重发请求：0次
    - 客户端重发请求：可能>0次
  - 如果一切工作正常，远程过程会被执行1次
  - 如果服务器在发送响应前崩溃或响应消息丢失，远程过程会被执行1次或者多次
    - 客户端不重发请求：1次
    - 客户端重发请求：可能>1次
- RPC 系统通常会提供 **至少一次** 或 **最多一次** 的语义，甚至不保证具体哪一种
  - 恰好一次很难实现

#### 4.1.5 RPC例：CORBA ORB

- CORBA： Common Object Request Broker Architecture
- OMG组织制定的一个工业规范，是一个体系结构和一组规范
  - 1991年CORBA1.1，2012年CORBA3.3
- 目的：在分布式环境下实现应用的集成，使基于对象的软件成员，在分布的、异构的环境下可重用、可移植、可互操作
  -  OMG的理念：不存在统一的硬件平台、操作系统、编程语言、网络协议、应用模式，必须在互操作上达成一致
- 方法：提供一个框架，如果符合这一框架，就可以在主要的硬件平台和操作系统上建立一个异质的分布式应用
- CORBA结合了当时计算机工业中的两个重要趋势：面向对象软件开发和客户机/服务器计算

#### 4.1.6 对象请求代理ORB

- 对象请求代理ORB（Object Request Broker）：定义异构环境下对象透明地发送请求和接收响应的基本机制。ORB 为客户隐藏：
  - 对象位置
  - 对象实现方式
  - 对象执行状态
  - 对象通信机制
- ORB并不需要作为一个单独的组件来实现。它定义了一系列的接口，任何一种支持了该接口的实现方式都是可行的

##### 4.1.6.1 ORB体系结构

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030183017.png" style="zoom:80%;" />

##### 4.1.6.2 ORB远程调用支持的执行语义

- 最多一次（at-most-once)
  - 如果操作请求能够成功地返回，那么该操作只被执行一次（exactly once)，如果返回异常，那么该操作是最多执行一次(at-most-once)。没有oneway修饰符的操作都属此类，即同步或延迟同步的操作调用方式都是这种语义
- 最大努力（best-effort)
  - 不能返回任何结果，且请求者从不与操作是否结束相同步。具有oneway修饰符的操作属此类

##### 4.1.6.3 OMG接口定义语言IDL

- CORBA对象接口采用接口定义语言IDL定义

  - 仅定义接口，不定义实现
  - 分隔“对象作什麽 (WHAT)”与“如何做 (HOW)”
  - 强类型、面向对象、语言中立的说明(描述)型语言
  - ANSI C++ 的子集
  - 支持多继承
  - 支持到多种语言的映射

- 目前有：Ada、C、C++、Java、Lisp、COBOL、Python、Smalltalk

- Role of CORBA IDL

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311643598.png" style="zoom: 67%;" />

- IDL的使用

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311645993.png" style="zoom:67%;" />

- IDL和Stub例

  - Hello.idl定义：

    ```idl
    interface Hello {
    	void say_hello();
    }
    // IDL到Java编译例：
    // jidl --package hello Hello.idl
    ```

  - 客户端 Stub：

    - HelloOperations.java：定义 `public interface HelloOperations`
    - Hello.java：定义接口 `Interface Hello`
    -  _HelloStub.java：桩代码，定义了`class _HelloStub`
    - HelloHelper.java：定义 `public class HelloHelper` 对象

  - 服务器端 Skeleton：

    - HelloOperations.java：定义 `public interface HelloOperations`
    - HelloHolder.java： 定义 `public final class HelloHolder`
    - HelloPOA.java：定义类 `abstract public class HelloPOA`

例 - HelloOperations、Hello：

```java
public interface HelloOperations {
    // IDL:Hello/say_hello:1.0
    void say_hello();
}
public interface Hello extends HelloOperations,
								org.omg.CORBA.Object,
								org.omg.CORBA.portable.IDLEntity {
}
```

##### 4.1.6.4 静态存根和骨架

- 静态IDL存根 (IDL stubs):

  - 编译时确定的的静态接口，位于客户对象本地, 对客户来说相当于远程的执行对象。由存根向ORB提交请求
  - 负责对请求参数的封装和发送，以及对返回结果的接收和解封装，并以适当的格式进行通信传输

  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311658055.png)

  例 - _HelloStub

  ```java
  public class _HelloStub extends org.omg.CORBA.portable.ObjectImpl
  						implements Hello {
  	public void say_hello() {
  	// ………
  	org.omg.CORBA.portable.OutputStream out = null;
  	org.omg.CORBA.portable.InputStream in = null;
  	// ………
  	out = _request("say_hello", true);
  	in = _invoke(out);
  	// ……….
  	}
  }
  ```

- 静态IDL骨架 ( IDL skeletons )：

  - 在本地调用执行对象服务，并与ORB通信
  - 针对执行对象来说，代表了远程客户。骨架接收经ORB来的请求，将请求参数解封装，识别客户所请求的服务，（向上）调用服务器中的对象实现，把执行结果封装，并将结果返回给客户程序

  例 - HelloPOA

  ```java
  public abstract class HelloPOA extends org.omg.PortableServer.Servant
  			implements org.omg.CORBA.portable.InvokeHandler, HelloOperations {
  	public org.omg.CORBA.portable.OutputStream _invoke(String opName,
  			org.omg.CORBA.portable.InputStream in,
  			org.omg.CORBA.portable.ResponseHandler handler) {
  		// …….
  		return _OB_op_say_hello(in, handler);
  	}
  	private org.omg.CORBA.portable.OutputStream
          _OB_op_say_hello(org.omg.CORBA.portable.InputStream in,
  		org.omg.CORBA.portable.ResponseHandler handler) {
  		// ……..
  		sayHello();
  		// ……..
  	}
  }
  ```

##### 4.1.6.5 对象实现和客户

- 对象实现（Object Implementation）

  - 通过为对象实例定义数据和为对象方法定义代码提供对象的语义
  - 对象可以具有不同的实现方式
  - 对象实现不依赖于ORB或者客户调用对象的方式
  - 一个对象的实现可以是其它对象的客户
  - 对象实现的实例Servant：译为伺服对象或者仆从

  ```java
  public class Hello_impl extends HelloPOA{
  	public void say_hello(){
  		System.out.println("Hello World!");
  	}
  }
  ```

- 服务器是一个（或一组）组件，能为其它组件提供某种服务。即，如果某个组件创建了一个对象，并能被其它组件通过对象引用来访问， 则拥有对象的组件就是该对象的服务器，其它组件对这个对象的请求操作都将由创建该组件的服务器来执行

  - 例如一个进程

    <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311708864.png" style="zoom: 80%;" />

  - 服务器程序例

    ```java
    public static void main(String args[]) {
    	//	………
    	//创建对象实现的实例
    	Hello_impl helloImpl = new Hello_impl(); 
    	Hello hello = helloImpl._this(orb);
    	// ………
    }
    ```

- 客户（Client）

  - 客户访问对象的对象引用，并且调用对象上的操作
  - 客户只知道对象的接口，通过调用感受对象的行为

##### 4.1.6.6 对象引用

- 对象引用 － 临时的不透明的句柄，标识ORB中的一个对象实例。它用于定位响应请求的对象实现
- 可互操作的对象引用IOR：在异构ORB间传递 OR

对象引用生成和发布例：

```java
public static void main(String args[]){
	// ………
	Hello_impl helloImpl = new Hello_impl();
	Hello hello = helloImpl._this(orb); //将本地对象引用转换为IOR
	// ……….
	String ref = orb.object_to_string(hello); //将IOR转换为String
	//将IOR字符串写入文件
	String refFile = "Hello.ref";
	java.io.FileOutputStream file = new java.io.FileOutputStream(refFile);
	java.io.PrintWriter out = new java.io.PrintWriter(file);
	out.println(ref);
	out.flush();
	file.close();
	// ……
}
```

- 对象引用的获取
  - 从命名服务或交易服务中获取
  - 使用工厂对象
  - 使用对象引用字符串。转换为字符串，在文件中 、 email 等中传 递 。 Object_to_string() 和 string_to_object();
  - ...

对象引用获取和使用例：

```java
public static void main(String args[]){
	// ………
	org.omg.CORBA.Object obj = orb.string_to_object("relfile:/Hello.ref");
	//将基类对象转换为子类对象，hello是本地stub的实例
	Hello hello = HelloHelper.narrow(obj); 
	hello.say_hello();
	// ……
}
final public class HelloHelper {
	public static Hello narrow(org.omg.CORBA.Object val) {
		// ……..
		org.omg.CORBA.portable.ObjectImpl _ob_impl;
		_HelloStub _ob_stub = new _HelloStub(); 
		// ……..
		return _ob_stub;
		// ……..
	}
	// ……
}
```

##### 4.1.6.7 ORB核心

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311716578.png" style="zoom:67%;" />

- ORB核心及接口
  - ORB内核提供了ORB最核心的功能，如ORB的启动、对象引用的解析、服务对象的定位、通信等。其接口同时为客户方和对象实现方所见，可直接为应用程序所使用：
    - 对象引用操作：提供对象引用的串化和反串化及对象引用复制、删除、比较及探测对象引用存在与否 等操作。如object_to_string();release();
    - ORB和对象适配器初始化：使应用得到指向ORB的对象引用。如ORB_init();
    - 获取初始对象引用：ORB规定了客户对象在ORB初始时获取初始对象引用的方法， 如resolve_initial_references();

##### 4.1.6.8 对象适配器

- CORBA对象：

  - 可看作是一个具有对象标识、对象接口及对象实现的抽象实体
  - 从客户程序的角度看，就是它获取到的对象引用 IOR。IOR中包含了对象的标识、接口类型及其他信息以查找对象实现（实际是查找伺服对象）

- 伺服对象（Servant）：

  - 指具体程序设计语言的对象实例或实体，通常存在于一个服务程序进程之中
  - `Hello_impl helloImpl = new Hello_impl();`

- 关联：服务器利用对象实现创建伺服对象，然后将这些服务端本地的对象实例转换为可供远程使用的CORBA对象：

  - 对象引用＝宿主服务器地址端口+POA标识＋ObjectID

  - 例：CORBA

    ```java
    Hello_impl helloImpl = new Hello_impl();
    Hello hello = helloImpl._this(orb);
    ```

    <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311725273.png" style="zoom: 67%;" />

- 对象适配器是管理服务端伺服对象（仆从）、对象标识、对象引用及它们之间关联的主要工具

  - 它负责决定在收到客户请求时应调用哪个伺服对象，然后调用该伺服对象上的合适操作
  - 例：POA： Portable Object Adapter
    - 对象引用＝宿主服务器地址端口+POA标识＋ObjectID
    - CORBA对象（IOR）与伺服对象之间可以不是一一对应的关系

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311728291.png" style="zoom:80%;" />

合在一起：Server

```java
public static void main(String args[]) {
	// ………
	orb = org.omg.CORBA.ORB.init(args,props); //初始化ORB
	//获取根POA
	org.omg.PortableServer.POA rootPOA = org.omg.PortableServer.POAHelper.narrow
									(orb.resolve_initial_references("RootPOA"));
	org.omg.PortableServer.POAManager manager = rootPOA.the_POAManager();
	Hello_impl helloImpl = new Hello_impl(); //创建伺服对象
	Hello hello = helloImpl._this(orb); //生成相应的CORBA对象，IOR
	// ……. // 将IOR转换为String，写入文件
	manager.activate(); //激活POA管理器，以允许接受请求
	orb.run(); //将控制权交给ORB，并处于运行状态
	// ……….
}
```

合在一起：Client

```java
public static void main(String args[]) {
	// ………
	orb = org.omg.CORBA.ORB.init(args,props); //初始化ORB
	// ………
	// 获取远端对象的引用
	org.omg.CORBA.Object obj = orb.string_to_object("relfile:/Hello.ref");
	Hello hello = HelloHelper.narrow(obj); 
	// ………
	hello.say_hello(); //调用远端对象的方法
	// ………
	System.exit(status); //退出
}
```

##### 4.1.6.9 ORB 总结

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311658055.png)

当Client要调用远程对象上的方法时，首先要得到这个远程对象的引用，之后就可以像调用本地对象方法一样调用远程对象的方法。当发出一个调用时，ORB通过客户Stub截取这个调用，对请求进行封装，将调用的名字、参数等编码成标准的方式(称Marshaling，编组)，并将请求发送给ORB核心。ORB核心解析IOR获得服务器IP地址端口号，将请求发送到服务器端。服务器方ORB核心收到请求，基于IOR中的POA标识，将请求送到相应POA，该POA基于IOR中的对象标识，送到相应的骨架对象（可能与伺服对象合为一个对象，因伺服对象类可通过继承骨架类实现）。骨架对象将参数解封装（Unmarshaling，解组） ，以本地对象方法调用的方式调用伺服对象相应业务方法从而完成调用。服务器对象完成处理后，ORB通过同样的编组/解组方式将结果返回给客户。

#### 4.1.7 再看RPC

##### RPC起源

- 一般认为，RPC的概念最早是由施乐公司在上实际80年代初期提出的
- 上一世纪中后期，惠普和Apollo提出了网络计算体系结构，并在DCE项目中将其发展为UNIX下的远程调用框架 DCE/RPC
  - DCE：OSF邀请当时主流计算机厂商参与的项目，制定了名为 “DCE，分布式计算环境” 的分布式技术体系
- 1988年，Sun公司起草并向IETF提交了RFC 1050规范，设计了一套面向广域网或混合式网络环境的，基于TCP/IP的、支持C语言的RPC协议，称为ONC RPC
- DCE/RPC和ONC RPC被认为是之后各种RPC协议和框架的鼻祖

##### RPC要解决的基本问题

- 几十年来，RPC早已不局限于远程过程调用，已经包括了远程对象方法、远程服务操作的调用
- 各种RPC协议都是希望能够比较好地解决以下三个问题
  - 如何表示数据
  - 如何传递数据
  - 如何表示方法

###### 如何表示数据

- 数据包括调用方法时传入的参数，和方法执行后的返回值
- RPC中，调用者和被调用者可以是异构的，需要将数据转换成某种事先约定好的中立数据格式进行传输，接收方再将数据流转换成自己语言对应的数据类型
  - 数据的序列化和反序列化
- 每种RPC协议有对应的序列化协议，如
  - ONC RPC的外部数据表示：XDR
  - CORBA的通用数据表示：CDR
  - Java RMI的Java对象序列流协议
  -  gRPC的Protocol Buffers
  - Web Service的XML序列化
  - 很多轻量级RPC支持的JSON序列化

###### 如何传递数据

- 如何通过网络，在调用者和被调用者的Endpoint之间互操作，交换数据
- 交换数据通常由应用层协议负责，一般基于TCP、UDP等传输层协议实现
  - 常用“wire protocol”来表示这种交换数据的机制
- 除交换序列化请求和响应，还有很多额外信息，常被称为上下文信息，如
  - 事务、安全、认证、授权等等
- 常见的wire protocol 如
  - CORBA的互联网ORB间协议IIOP
  - Java RMI的远程消息交换协议JRMP，也支持RMI-IIOP
  - Web Service的简单对象访问协议SOAP，可用HTTP传输
  - 若双方都是HTTP Endpoint，可直接使用HTTP传输，如JSON-RPC

**SOAP消息请求例**

```xml
POST /StockQuote HTTP/1.1 
Host: example.com 
Content-Type: text/xml; charset="utf-8" 
Content-Length: nnnn
SOAPAction: "http://example.com/GetLastTradePrice" 
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" 
	SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"> 
	<SOAP-ENV:Body> 
		<m:TradePriceRequest xmlns:m="http://example.com/stockquote.xsd"> 
		<tickerSymbol>MSFT</tickerSymbol > 
		</m:TradePriceRequest> 
	</SOAP-ENV:Body> 
</SOAP-ENV:Envelope> 
```

<a href="https://blog.csdn.net/starnight_cbj/article/details/4986857" target="_blank">WSDL</a>

**SOAP消息响应例**

```xml
HTTP/1.1 200 OK 
Content-Type: text/xml; charset="utf-8" 
Content-Length: nnnn
<SOAP-ENV:Envelope xmlns:
		SOAP- ENV=http://schemas.xmlsoap.org/soap/envelope/
		SOAP-ENV:
		encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/> 
	<SOAP-ENV:Body> 
		<m:TradePriceResult xmlns:m="http://example.com/stockquote.xsd "> 
			<price>74.5</price>
		</m:TradePriceResult > 
	</SOAP-ENV:Body> 
</SOAP-ENV:Envelope>
```

**JSON-RPC请求响应例**

```json
// 请求
{ 
	"jsonrpc":"2.0", 
	"method": "subtract", 
	"params":[42, 23], 
	"id": 1 
}
// 响应
{ 
	"jsonrpc":"2.0",
	"result": 19,
	"id": 1
}
```

###### 如何表示方法

- “如何表示同一个方法”，“如何找到对应的方法”等，需要一个统一的跨语言的标准
- 用于表示方法的协议如
  - DCE的 IDL （Interface Description Language）
  - CORBA的 IDL
  - Web Service的WSDL
  - Android的 AIDL

**CORBA IDL**

```idl
Module BANK {
	Interface BANKAccount{
		enum account_kind {checking,saving};
		exception account_not_available{string,reason};
		exception incorrect_PIN{}；
		readonly attribute float balance;
		attribue account_kind kind_of_account;
		void access(in string account, in string pin)
			raises(accout_not_available,incorrect_pin);
		void deposit (in float f, out float new_balance)
			raises (account_not_available);
		void withdraw (in float f, out float new_balance)
			raises (account_not_available);
		oneway op1(in int i);
	}
}
```

**WSDL 文档示例**

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311754500.png" style="zoom: 80%;" />

##### 谁能一统江湖？

- 上世纪80年代的DCE RPC和 ONC RPC从没在UNIX之外大规模流行过，且面向C语言设计，不支持对象的概念
- 上世纪90年代的CORBA由国际标准化组织OMG牵头，支持C、C++、Java、List、Python、Ruby等，阵营强、影响大
  - 设计繁琐，规范晦涩难懂，各语言厂商解读不一致难以兼容
- 微软的DCOM受限于操作系统
- 1998年，XML1.0发布；1999年，SOAP1.0发布；“Web Service”正式登上历史舞台，风头一时无两
  - 过于严格的数据和接口定义附带的是性能问题
    - XML本身信息密度相对低下
    - 要跨语言，使得一个简单的字段，为了在多种语言中不产生歧义，需要多出十几倍、几十倍甚至上百倍的空间
  - 希望在一套协议上一揽子解决分布式计算中可能遇到的所有问题：事务、一致性、事件、安全……，加重学习负担
- 简单、普适、高性能，似乎很难同时满足

##### 百家争鸣的RPC

- RPC领域逐渐进入群雄混战、百家争鸣的战国时代。任何一款具有生命力的RPC框架，不再追求完美，而是针对某个特点进行重点发展，如
  - 朝着面向对象发展，如RMI、.NET Remoting，CORBA、DCOM
  - 朝着高性能发展，如gRPC、Thrift
    - 二者都有自己专用的高效序列化器
    -  gRPC基于HTTP/2；Thrift直接基于TCP，省去了应用层协议的开销
  - 朝着简化发展，如JSON-RPC
    - 协议简单轻便，接口与格式都更为通用

##### RPC框架的发展趋势

- 近年来，RPC框架有向更高层次与插件化方向发展的趋势
- 不仅负责远程过程调用，还管理远程服务
- 不再追求独自解决RPC的三个问题，而是将一部分功能设置为扩展点
- 例如阿里的Dubbo框架
  - 可用来处理分布式系统中，服务发现、注册以及调用问题，并且管理调用过程
  - 不仅支持自己的传输协议（Dubbo协议），还支持其它协议
  - 默认采用Hessian 2作为序列化器，还可以替换为Fastjson、Protocol Buffers等序列化器，甚至可以直接使用JDK自带的序列化器

### 4.2 REST

#### 4.2.1 简介

- REST：REpresentation State Transfer，表现层（表示/表征/表述性/具象)状态转移（传输）
- 加上主语，是 Resource Representational State Transfer
  - Resource：资源，如某文章、newsfeed，friends
  - Representation：某种表现形式，如某文章有HTML、PDF、RSS
  - State Transfer：状态转移，从“当前文章”转移到“下一篇文章”
    - 通过HTTP动词实现：如GET、PUT、POST、DELETE
- 首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之一

#### 4.2.2 State Transfer

- 服务器可以生成包含状态转移的数据，用来响应客户端对于一个资源的请求
- 客户端借助这份表征数据，得到了当前的状态以及对应可转移状态的方式

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/202210311914212.png" style="zoom: 50%;" />

#### 4.2.3 REST架构

- 








