# Chapter 3 通信

## 1 分层通信协议

### 1.1 OSI 模型

#### 1.1.1 简介

- 由于没有共享存储器，分布式系统中的所有通信是基于（低层）消息交换的
- OSI模型（开放式系统互联参考模型）用来支持开放式系统间的通信
- 开放式系统是可以通过标准规则与其他开放式系统通信的系统，这些规则规定了发送和接收消息的格式、内容以及相应的含义

#### 1.1.2 OSI模型中的层、结构和协议

- 分层：功能分解。独立性
- 接口（提供功能的操作集）：标准化
- 协议栈：有序性

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030171307.png" style="zoom:80%;" />

#### 1.1.3 典型消息格式

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030171449.png" style="zoom:80%;" />

### 1.2 应用层协议

- 在OSI七层模型的传输层之上划分了三个层，在实践中，只用到了其中的应用层
- 在Internet协议簇中，传输层之上的所有内容都合并到了一起，称为应用层
  - 应用层成为所有由于各种原因不能归纳到某个较低层中去的应用程序和协议的容器
- 缺乏对应用程序、针对特定应用程序的协议以及通用协议的明确区分
  - ftp协议和ftp程序
  - HTTP协议

### 1.3 中间件

#### 1.3.1 中间件协议

- 有的应用层协议，可用于支持多种应用程序的通信，因此可看做是对多种应用程序有用的通用协议
  - 但不能算作传输层协议，很多情况下归入 **中间件协议**
- 中间件协议：中间件使用的，用于建立各种中间件服务的协议，如支持通信、认证、事务、容错……
- 不同的中间件系统有不同的中间件协议，如
  - 支持远程过程调用的协议，如
    - CORBA的IIOP
    - Java RMI的JRMP
    - Web Service的SOAP和HTTP
    -  gRPC的HTTP/2
  - 支持实时流数据传输并保持同步的协议
  - 可靠多播协议，用于支持可靠多播服务的中间件系统

#### 1.3.2 中间件层

中间件层在通信中所处的位置：

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030172025.png" style="zoom:80%;" />

#### 1.3.3 中间件支持的通信类型

- 从通信持久性方面
  - 持久通信：传输的消息一直由通信中间件存储，直到该消息被传送给接收方，如电子邮件系统
  - 瞬时通信：通信中间件只在发送和接收应用程序正在运行的时候才存储消息，即由于传输中断或者接收方当前不在活动状态，中间件就不传输消息，而是丢弃消息
- 从通信同步性方面
  - 同步通信：发送方提交消息后将被阻塞，直到某个事件发生：发送方可有三类同步点
    - 基于发送：中间件确认接管消息传送
    - 基于接收：请求被传送到目标接收方
    - 基于响应：接收方返回响应
  - 异步通信：发送方在提交要传输的消息后立刻接着后续的执行，不会阻塞
    - 发送方提交的消息立刻被中间件存储
- 从通信连续性方面分：不连续通信和流通信
- 这些通信方式可以进行各种组合

#### 1.3.4 通信持久性和同步性的组合例

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030172453.png" style="zoom:80%;" />

## 2 套接字

### 2.1 面向消息的瞬时通信：套接字

- 很多分布式系统和应用程序直接构建在传输层提供的简单的面向消息的模型之上
- 程序员通过一个简单的原语集就可以使用传输层提供的全部（消息传递）协议
  - 标准化的原语集接口使得应用程序在不同机器之间的移植变得容易
- 如支持TCP/IP的Berkeley套接字socket

### 2.2 TCP/IP套接字原语

| 原语    | 意义                             |
| ------- | -------------------------------- |
| Socket  | 创建新的通信端点                 |
| Bind    | 将本地地址附加(attach)到套接字上 |
| Listen  | 宣布已准备好接受连接             |
| Accept  | 在准备好连接请求之前阻塞调用方   |
| Connect | 主动尝试确立连接                 |
| Send    | 通过连接发送数据                 |
| Receive | 通过连接接受数据                 |
| Close   | 释放连接                         |

### 2.3 使用套接字的面向连接通信模式

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030173035.png)

### 2.4 套接字编程

```java
// Server:
ServerSocket server = new ServerSocket(10000);
while (true) {
	Socket s= server.accept();
	new ServerThread(s).start();
}

// Client
Socket s = new Socket(“192.168.2.1”,10000);
InputStream is = s.getInputStream();
is.close();
s.close();
```

## 3 应用层协议和中间件协议例：HTTP

### 3.1 HTTP 简介

- HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从Web服务器传输超文本到本地浏览器的传输协议
- 工作于客户端-服务端架构上。浏览器作为HTTP客户端，通过URL向HTTP服务端即WEB服务器发送所有请求
- 基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）
  - 默认端口号为80，但是也可以改为8080或者其他端口

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030173500.png)

### 3.2 HTTP 请求

#### 3.2.1 HTTP 请求响应交互

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221030173717217.png" style="zoom:80%;" />

1. 在用户点击URL为http://www.bupt.edu.cn/index.html的链接后，浏览器执行以下动作：
   1. 浏览器分析超链接中的URL
   2. 浏览器向DNS请求解析www.bupt.edu.cn的IP地址
   3. DNS将解析出的IP地址124.127.207.15返回浏览器
2. 浏览器与服务器建立TCP连接（80端口）
3. 浏览器请求文档：GET /index.html
4. 服务器给出响应，将文档 index.html 发送给浏览器
5. 释放TCP连接
6. 浏览器显示index.html中的内容

#### 3.2.2 HTTP的消息格式

- HTTP消息分为请求消息和响应消息两类

- 请求消息：从客户端(浏览器)向Web服务器发送的请求报文

- 请求消息例：

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174300.png" style="zoom: 67%;" />

#### 3.2.3 请求消息中的方法

方法(Method)是对所请求对象所进行的操作，也就是一些命令。请求报文中的操作有

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174506.png" style="zoom:80%;" />

#### 3.2.4 响应消息

- 从Web服务器到客户机(浏览器)的应答

- 响应消息例：

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174739.png" style="zoom:67%;" />

#### 3.2.5 响应消息中的状态码

状态码(Status-Code)是响应报文状态行中包含的一个3位数字，指明特定的请求是否被满足，如果没有满足，原因是什么。状态码分为以下五类

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221030174848782.png)

#### 3.2.6 HTTP消息结构:首部字段或消息头

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030174930.png)

### 3.3 HTTP的连接方式

- 非持久性连接
  - 即浏览器每请求一个Web文档，就创建一个新的连接，当文档传输完毕后，连接就立刻被释放
  - HTTP/1.0、HTTP/0.9采用此连接方式
- 持久性连接
  - 即在一个连接中，可以进行多次文档的请求和响应。服务器在发送完响应后，并不立即释放连接，浏览器可以使用该连接继续请求其他文档
  - HTTP/1.1默认使用持久连接

### 3.4 HTTP/1.x的主要问题

- HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟
- 单向请求，只能由客户端发起
- 请求报文与响应报文首部信息冗余量大
- 数据未压缩，导致数据的传输量大

### 3.5 HTTP/2主要的新特性

- **二进制分帧**：HTTP/1.x通过文本的方式传输数据，HTTP/2中引入了新的编码机制，所有传输的数据都会被分割为帧，并采用二进制格式编码
- **多路复用**：HTTP/2中,基于二进制分帧层，可以在共享TCP连接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。 通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能
- **首部压缩**：HTTP/1.x的header带有大量信息，而且每次都要重复发送，HTTP/2使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
- **服务器推送**：服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/image-20221030175508853.png" style="zoom:80%;" />

参考：<a href="https://blog.csdn.net/weixin_41605937/article/details/108306408">计算机网络——HTTP协议原理</a>

### 3.6 HTTP的无状态性

- 无状态协议，是指协议对于交互性场景没有记忆能力，协议本身并不保留之前一切的请求或响应报文的信息
- 对于一般的Web资源而言，一个URL对应着唯一的超文本，而HTTP服务器也绝对公平公正，不管请求者是谁，之前还请求过什么，它都会根据接收到的URL请求返回相同的超文本。**每次请求都是独立的**
  - 这样，记录用户的行为状态变得毫无意义，所以，HTTP协议被设计为无状态协议符合它本身的需求
- HTTP的无状态性简化了服务器的设计，使其更容易支持大量并发的HTTP请求
  - 集群、cache都方便
- 为支持有状态的服务，HTTP引入了Cookie技术，例如
  - 当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标识Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 进行保存
  - 在这个会话期间，浏览器每次请求都会额外加上这个参数值，服务器根据这个 SessionId，就能取得该客户的会话信息进行有针对性的响应
- Cookie技术为传递用于标识客户身份或者会话ID的信息提供了支持，**但这些信息并不是协议自身保存的**
  - HTTP仍然是一个无状态协议

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030135416.png" style="zoom:80%;" />

### 3.7 HTTP做中间件协议：传输SOAP

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180031.png" style="zoom:80%;" />

## 4 访问远程服务

### 4.1 远程过程调用RPC

#### 4.1.1 RPC概述

- **R**emote **P**rocedure **C**all：像调用本地过程一样，调用远程过程

  - 调用者和被调者都不用考虑通信问题

  - 沿用用户熟悉的编程模式，调用远端过程并将结果返回

- 通信一般采用同步方式（Request-Wait-Reply）

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180323.png" style="zoom:80%;" />

#### 4.1.2 远程过程调用机制

- 在发送方（调用方）的地址空间里创建一个远程组件（如过程）的代理（客户侧Stub）；在接收方（被调用方）的地址空间里创建一个发送方代理（服务器侧Stub）

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180435.png" style="zoom:80%;" />

- 发送方只和本地客户侧Stub通信；接收方从本地服务器侧Stub得到所有的请求

- 组件间的远程通信封装在代理／Stub通信中，它是由建立在中间件API基础上的IDL编译器生成的

  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180625.png" style="zoom:80%;" />

#### 4.1.3 远程方法调用RMI

像调用本地对象的方法一样，调用远程对象的方法，调用者和被调者都不用考虑通信问题。

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030180743.png)

#### 4.1.4 RPC的执行语义

- RPC百分百一次性调用成功是非常难以实现的，例如：
  - 如果服务器在执行过程调用之前崩溃或请求消息丢失
    - 客户端不重发请求：0次
    - 客户端重发请求：可能>0次
  - 如果一切工作正常，远程过程会被执行1次
  - 如果服务器在发送响应前崩溃或响应消息丢失，远程过程会被执行1次或者多次
    - 客户端不重发请求：1次
    - 客户端重发请求：可能>1次
- RPC 系统通常会提供 **至少一次** 或 **最多一次** 的语义，甚至不保证具体哪一种
  - 恰好一次很难实现

#### 4.1.5 RPC例：CORBA ORB

- CORBA： Common Object Request Broker Architecture
- OMG组织制定的一个工业规范，是一个体系结构和一组规范
  - 1991年CORBA1.1，2012年CORBA3.3
- 目的：在分布式环境下实现应用的集成，使基于对象的软件成员，在分布的、异构的环境下可重用、可移植、可互操作
  -  OMG的理念：不存在统一的硬件平台、操作系统、编程语言、网络协议、应用模式，必须在互操作上达成一致
- 方法：提供一个框架，如果符合这一框架，就可以在主要的硬件平台和操作系统上建立一个异质的分布式应用
- CORBA结合了当时计算机工业中的两个重要趋势：面向对象软件开发和客户机/服务器计算

#### 4.1.6 对象请求代理ORB

- 对象请求代理ORB（Object Request Broker）：定义异构环境下对象透明地发送请求和接收响应的基本机制。ORB 为客户隐藏：
  - 对象位置
  - 对象实现方式
  - 对象执行状态
  - 对象通信机制
- ORB并不需要作为一个单独的组件来实现。它定义了一系列的接口，任何一种支持了该接口的实现方式都是可行的

##### 4.1.6.1 ORB体系结构

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12632/20221030183017.png" style="zoom:80%;" />

##### 4.1.6.2 ORB远程调用支持的执行语义

- 最多一次（at-most-once)
  - 如果操作请求能够成功地返回，那么该操作只被执行一次（exactly once)，如果返回异常，那么该操作是最多执行一次(at-most-once)。没有oneway修饰符的操作都属此类，即同步或延迟同步的操作调用方式都是这种语义
- 最大努力（best-effort)
  - 不能返回任何结果，且请求者从不与操作是否结束相同步。具有oneway修饰符的操作属此类

##### 4.1.6.3 OMG接口定义语言IDL


